# 웹 빌더 프로젝트 핵심 기능 분석

## 프로젝트 개요

이 Next.js 웹 빌더는 Feature-Sliced Design (FSD) 아키텍처를 기반으로 한 드래그 앤 드롭 비주얼 웹 에디터입니다.

**주요 기술 스택:**
- Frontend: Next.js 15.5.2, React 19.1.0, TypeScript
- 스타일링: Tailwind CSS 4 + 인라인 CSS 스타일
- 상태관리: Zustand
- 드래그 앤 드롭: @dnd-kit
- UI 컴포넌트: shadcn/ui (Radix UI 기반)

---

## 1. Add Element 드롭다운 메뉴 시스템

### 📍 핵심 파일
- `src/widgets/layout.tsx` - 드롭다운 UI 구현
- `src/shared/lib/element-factory.ts` - 엘리먼트 생성 로직
- `src/processes/editor-store.ts` - 상태 관리

### 🔄 작동 원리

```typescript
// 1. 사용자가 드롭다운에서 엘리먼트 타입 선택
const elementTypes = [
  { type: "text", label: "텍스트", icon: <Type /> },
  { type: "button", label: "버튼", icon: <MousePointer2 /> },
  // ... 더 많은 타입들
];

// 2. handleAddElement 함수가 호출됨
const handleAddElement = (type: ElementType) => {
  const newElement = createElement(type);
  addElement(newElement);
};

// 3. createElement가 기본값으로 새 엘리먼트 생성
export function createElement(type: ElementType, overrides: Partial<Element> = {}): Element {
  const baseElement = {
    id: generateId(),
    x: 100, y: 100, // 기본 위치
    width: 200, height: 100, // 기본 크기
    zIndex: 1,
    padding: { top: 8, right: 12, bottom: 8, left: 12 }
  };
  
  // 타입별 특화 속성 추가
  switch (type) {
    case "text":
      return { ...baseElement, content: "새 텍스트", fontSize: 16, ... };
    // ...
  }
}

// 4. Zustand store의 addElement가 상태 업데이트
addElement: (element) => {
  set((state) => ({
    canvas: {
      ...state.canvas,
      elements: [...state.canvas.elements, element],
      selectedElementIds: [element.id]
    }
  }));
  get().saveToHistory();
}
```

### 🎯 데이터 플로우
```
사용자 클릭 → handleAddElement → createElement → addElement (Zustand) → Canvas 리렌더링 → 새 엘리먼트 표시
```

---

## 2. 컴포넌트 캔버스 렌더링 시스템

### 📍 핵심 파일
- `src/widgets/canvas.tsx` - 캔버스 컨테이너
- `src/features/draggable-element.tsx` - 드래그 가능한 래퍼
- `src/entities/*-element.tsx` - 각 엘리먼트 컴포넌트

### 🔄 렌더링 과정

```typescript
// 1. Canvas 컴포넌트가 모든 엘리먼트를 순회
{elements.map((element) => (
  <DraggableElement key={element.id} element={element}>
    {/* 2. 엘리먼트 타입에 따라 적절한 컴포넌트 렌더링 */}
    {renderElement(element)}
  </DraggableElement>
))}

// 3. renderElement 함수가 타입별 컴포넌트 선택
function renderElement(element: Element) {
  switch (element.type) {
    case "text":
      return <TextElementComponent element={element} />;
    case "button":
      return <ButtonElementComponent element={element} />;
    // ...
  }
}
```

### 🎨 위치 및 스타일 적용
각 엘리먼트는 절대 위치(`position: absolute`)로 배치되며, 인라인 스타일로 동적 속성이 적용됩니다:

```typescript
// TextElement 예시
<div
  className="absolute cursor-pointer select-none"
  style={{
    left: element.x,          // 동적 X 위치
    top: element.y,           // 동적 Y 위치
    width: actualWidth,       // 계산된 실제 너비
    height: actualHeight,     // 계산된 실제 높이
    zIndex: element.zIndex,   // Z-인덱스
    fontSize: element.fontSize,
    color: element.color,
    // ... 기타 동적 스타일
  }}
>
```

---

## 3. 속성 패널 커스터마이징 시스템

### 📍 핵심 파일
- `src/widgets/property-panel.tsx` - 속성 패널 메인
- `src/processes/editor-store.ts` - 엘리먼트 업데이트 로직

### 🔄 동적 속성 렌더링

```typescript
// 1. 선택된 엘리먼트 타입에 따라 다른 속성 폼 렌더링
const renderProperties = () => {
  if (!selectedElement) return null;
  
  switch (selectedElement.type) {
    case "text":
      return renderTextProperties(selectedElement);
    case "button":  
      return renderButtonProperties(selectedElement);
    // ...
  }
};

// 2. 타입별 속성 렌더링 함수
const renderTextProperties = (element: TextElement) => (
  <>
    {/* 공통 속성 */}
    <PropertyInput label="X 위치" value={element.x} onChange={...} />
    <PropertyInput label="Y 위치" value={element.y} onChange={...} />
    
    {/* 텍스트 특화 속성 */}
    <PropertyInput label="텍스트" value={element.content} onChange={...} />
    <PropertyInput label="글자 크기" value={element.fontSize} onChange={...} />
    <ColorPicker label="색상" value={element.color} onChange={...} />
  </>
);
```

### 🎛️ 스마트 타입 변환 시스템

```typescript
// 자동 타입 변환 핸들러
const createAutoTypeHandler = (property: string, elementId: string) => {
  return (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    const inputType = e.target.type;
    
    let processedValue: string | number = value;
    
    // 숫자 타입 자동 변환
    if (inputType === "number") {
      processedValue = value === "" ? 0 : parseFloat(value);
    }
    // 텍스트 타입 스마트 처리 (auto 키워드 지원)
    else if (inputType === "text") {
      if (value === "auto") {
        processedValue = "auto";
      } else {
        const numValue = parseFloat(value);
        processedValue = isNaN(numValue) ? value : numValue;
      }
    }
    
    updateElement(elementId, { [property]: processedValue });
  };
};
```

---

## 4. 그리드 스냅 시스템

### 📍 핵심 파일
- `src/processes/editor-store.ts` - 그리드 설정 및 스냅 로직
- `src/widgets/canvas.tsx` - 그리드 시각화

### 🔄 그리드 스냅 알고리즘

```typescript
// 그리드 설정
interface GridConfig {
  showGrid: boolean;      // 그리드 표시 여부
  columns: 24;           // 24컬럼 그리드
  rows: 20;              // 20로우 그리드
  cellSize: 80;          // 80px 셀 크기 (1920px ÷ 24 = 80px)
  snapToGrid: boolean;   // 스냅 활성화 여부
}

// 스냅 계산 함수
snapToGrid: (x: number, y: number) => {
  const { grid } = get();
  if (!grid.snapToGrid) return { x, y };
  
  const cellSize = grid.cellSize;
  return {
    x: Math.round(x / cellSize) * cellSize,  // 가장 가까운 그리드 점으로 스냅
    y: Math.round(y / cellSize) * cellSize,
  };
}
```

### 🎨 그리드 시각화 (SVG 패턴 사용)

```typescript
// 효율적인 SVG 패턴으로 그리드 렌더링
<svg className="absolute inset-0 pointer-events-none">
  <defs>
    <pattern
      id="grid"
      width={grid.cellSize}
      height={grid.cellSize}
      patternUnits="userSpaceOnUse"
    >
      <path
        d={`M ${grid.cellSize} 0 L 0 0 0 ${grid.cellSize}`}
        fill="none"
        stroke="rgba(0,0,0,0.1)"
        strokeWidth="1"
      />
    </pattern>
  </defs>
  <rect width="100%" height="100%" fill="url(#grid)" />
</svg>
```

### 🎯 스마트 그리드 표시
그리드는 드래그 중에만 표시되어 UI 복잡도를 줄입니다:

```typescript
// 드래그 상태에 따른 그리드 자동 표시/숨김
if (!grid.showGrid || !isDragging) return null;
```

---

## 5. 줌 인/아웃 시스템

### 📍 핵심 파일
- `src/widgets/canvas.tsx` - 줌 UI 및 로직
- `src/processes/editor-store.ts` - 줌 상태 관리

### 🔄 줌 구현 방식

```typescript
// 1. CSS Transform을 활용한 GPU 가속 줌
<div 
  className="canvas-content"
  style={{ 
    transform: `scale(${canvasZoom})`,
    transformOrigin: "top left"
  }}
>
  {/* 모든 캔버스 콘텐츠 */}
</div>

// 2. 휠 이벤트를 통한 부드러운 줌
const handleWheel = useCallback((e: WheelEvent) => {
  if (!e.ctrlKey && !e.metaKey) return;  // Ctrl/Cmd 키 필수
  e.preventDefault();
  
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;  // 10% 단위 줌
  const newZoom = Math.max(0.1, Math.min(3, canvasZoom * zoomFactor));
  setCanvasZoom(newZoom);
}, [canvasZoom, setCanvasZoom]);

// 3. 드래그 앤 드롭에서 줌 레벨 고려
const handleDragEnd = (event: DragEndEvent) => {
  const { delta } = event;
  
  // 줌 스케일을 고려한 실제 이동 거리 계산
  const scaledDeltaX = delta.x / canvasZoom;
  const scaledDeltaY = delta.y / canvasZoom;
  
  const newX = element.x + scaledDeltaX;
  const newY = element.y + scaledDeltaY;
  
  // 그리드 스냅 적용
  const snappedPosition = snapToGrid(newX, newY);
  moveElement(element.id, snappedPosition.x, snappedPosition.y);
};
```

---

## 6. 드래그 앤 드롭 시스템

### 📍 핵심 파일
- `src/features/drag-drop.tsx` - DnD 컨텍스트 프로바이더
- `src/features/draggable-element.tsx` - 드래그 가능한 엘리먼트 래퍼

### 🔄 @dnd-kit 기반 구현

```typescript
// 1. 센서 설정 (의도하지 않은 드래그 방지)
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: {
      distance: 8,  // 8px 이상 이동해야 드래그 시작
    },
  })
);

// 2. 드래그 시작 시 그리드 표시
const handleDragStart = (event: DragStartEvent) => {
  setIsDragging(true);
  
  // 원래 그리드 설정 백업
  const currentGrid = grid.showGrid;
  setOriginalGridShow(currentGrid);
  
  // 드래그 중 그리드 강제 표시
  if (!currentGrid) {
    setGrid({ showGrid: true });
  }
};

// 3. 드래그 종료 시 위치 업데이트 및 그리드 복원
const handleDragEnd = (event: DragEndEvent) => {
  setIsDragging(false);
  
  // 그리드 설정 복원
  if (originalGridShow !== null) {
    setGrid({ showGrid: originalGridShow });
    setOriginalGridShow(null);
  }
  
  // ... 위치 업데이트 로직
};
```

---

## 7. 상태 관리 시스템 (Zustand)

### 📍 핵심 파일
- `src/processes/editor-store.ts` - 메인 에디터 스토어

### 🏗️ 스토어 구조

```typescript
interface EditorState {
  // 캔버스 상태
  canvas: {
    elements: Element[];           // 모든 엘리먼트
    selectedElementIds: string[];  // 선택된 엘리먼트 ID들
    width: 1920;                  // 캔버스 너비
    height: 1080;                 // 캔버스 높이
  };
  
  // 히스토리 (Undo/Redo용)
  history: Canvas[];              // 상태 히스토리
  historyIndex: number;           // 현재 히스토리 인덱스
  
  // UI 상태
  isDragging: boolean;            // 드래그 상태
  isResizing: boolean;            // 리사이징 상태
  canvasZoom: number;             // 줌 레벨
  
  // 그리드 설정
  grid: GridConfig;
}
```

### 🔄 주요 액션들

```typescript
// 엘리먼트 추가
addElement: (element) => {
  set((state) => ({
    canvas: {
      ...state.canvas,
      elements: [...state.canvas.elements, element],
      selectedElementIds: [element.id]  // 새 엘리먼트 자동 선택
    }
  }));
  get().saveToHistory();  // 히스토리 저장
};

// 엘리먼트 속성 업데이트
updateElement: (id, updates) => {
  set((state) => ({
    canvas: {
      ...state.canvas,
      elements: state.canvas.elements.map(el =>
        el.id === id ? { ...el, ...updates } : el
      )
    }
  }));
  get().saveToHistory();
};

// 다중 선택 지원
toggleElementSelection: (id) => {
  set((state) => {
    const isSelected = state.canvas.selectedElementIds.includes(id);
    const newSelection = isSelected
      ? state.canvas.selectedElementIds.filter(selectedId => selectedId !== id)
      : [...state.canvas.selectedElementIds, id];
    
    return {
      canvas: { ...state.canvas, selectedElementIds: newSelection }
    };
  });
};
```

---

## 8. 스타일링 시스템 분석

### 🎨 현재 스타일링 방식: **하이브리드 접근법**

이 프로젝트는 **Tailwind CSS + 인라인 CSS 스타일**의 하이브리드 방식을 사용합니다:

#### **정적 스타일링**: Tailwind CSS
```typescript
// 레이아웃, 상태 표시 등 고정적인 스타일
<div className={cn(
  "absolute cursor-pointer select-none",
  isSelected ? "ring-2 ring-blue-500 ring-offset-2" : ""
)} />
```

#### **동적 스타일링**: 인라인 CSS
```typescript
// 사용자가 조정 가능한 동적 속성들
style={{
  left: element.x,              // 위치
  top: element.y,
  width: actualWidth,           // 크기
  height: actualHeight,
  fontSize: element.fontSize,   // 텍스트 속성
  color: element.color,
  backgroundColor: element.backgroundColor,
  // ... 모든 커스터마이징 가능한 속성
}}
```

---

## 9. 웹 빌더 특성상 동적 스타일링 최적화 분석

### 🎯 **왜 현재 방식이 적절한가?**

#### ✅ **인라인 스타일의 장점 (웹 빌더 특성상)**
1. **실시간 반영**: 속성 변경이 즉시 DOM에 반영
2. **동적 값 처리**: 사용자 입력값을 직접 CSS로 변환 가능
3. **타입 안전성**: TypeScript로 스타일 값 검증 가능
4. **스코프 격리**: 각 엘리먼트의 스타일이 독립적으로 관리

#### ✅ **Tailwind CSS의 장점 (시스템 스타일)**
1. **일관된 디자인 시스템**: 색상, 간격, 타이포그래피 통일
2. **개발 생산성**: 유틸리티 클래스로 빠른 스타일링
3. **번들 최적화**: 사용하지 않는 클래스 자동 제거
4. **반응형 디자인**: 쉬운 반응형 처리

### 🚀 **성능 최적화 측면**

#### **인라인 스타일 vs CSS-in-JS vs 동적 클래스**

| 방식 | 렌더링 속도 | 메모리 사용 | 개발 복잡도 | 웹 빌더 적합성 |
|------|------------|------------|------------|--------------|
| 인라인 스타일 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| CSS-in-JS | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| 동적 클래스 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |

#### **현재 방식의 성능 장점**
- CSS 파싱/매칭 단계 생략
- 스타일 계산이 직접적
- 리플로우/리페인트 최소화

---

## 10. 서버 저장 스타일링 데이터 처리 방안

### 🏗️ **권장 아키텍처: JSON + CSS 변수 하이브리드**

#### **Phase 1: 현재 구조 유지 (JSON 저장)**
```json
{
  "elements": [
    {
      "id": "text-1",
      "type": "text",
      "x": 100,
      "y": 200,
      "width": 300,
      "height": "auto",
      "content": "Hello World",
      "fontSize": 24,
      "color": "#333333",
      "fontFamily": "Inter",
      "textAlign": "center"
    }
  ]
}
```

#### **Phase 2: CSS 변수 최적화 (향후 고려)**
```json
{
  "cssVariables": {
    "--primary-color": "#3b82f6",
    "--text-lg": "18px",
    "--spacing-md": "16px"
  },
  "elements": [
    {
      "id": "text-1",
      "styles": {
        "color": "var(--primary-color)",
        "fontSize": "var(--text-lg)"
      }
    }
  ]
}
```

### 🎯 **성능 최적화 전략**

#### **1. 청크 단위 로딩**
```typescript
// 큰 프로젝트의 경우 섹션별 로딩
interface ProjectChunk {
  id: string;
  elements: Element[];
  viewport: { x: number, y: number, width: number, height: number };
}

// 현재 뷰포트 영역의 엘리먼트만 로딩
const loadVisibleElements = async (viewport: Viewport) => {
  const chunks = await api.getProjectChunks(projectId, viewport);
  return chunks.flatMap(chunk => chunk.elements);
};
```

#### **2. 증분 업데이트**
```typescript
// 전체 프로젝트 다시 저장하지 않고 변경된 엘리먼트만 업데이트
interface ElementUpdate {
  id: string;
  changes: Partial<Element>;
  timestamp: number;
}

const saveElementChanges = debounce(async (updates: ElementUpdate[]) => {
  await api.updateElements(projectId, updates);
}, 1000);
```

#### **3. 스타일 캐싱**
```typescript
// 자주 사용되는 스타일 조합을 캐시
interface StylePreset {
  id: string;
  name: string;
  styles: Partial<Element>;
}

const applyStylePreset = (elementId: string, presetId: string) => {
  const preset = styleCache.get(presetId);
  if (preset) {
    updateElement(elementId, preset.styles);
  }
};
```

### 🔄 **데이터 동기화 전략**

#### **실시간 협업을 위한 OT (Operational Transformation)**
```typescript
interface Operation {
  type: 'update' | 'create' | 'delete' | 'move';
  elementId: string;
  changes: any;
  userId: string;
  timestamp: number;
}

// 충돌 해결 알고리즘
const resolveConflicts = (localOps: Operation[], remoteOps: Operation[]) => {
  // Last-write-wins 또는 정교한 OT 알고리즘 적용
  return mergeOperations(localOps, remoteOps);
};
```

---

## 11. 최종 권장사항

### 🎯 **현재 스타일링 방식 유지 이유**

1. **웹 빌더 특성상 최적**: 사용자 커스터마이징이 주요 기능
2. **개발 생산성**: 복잡한 CSS-in-JS 설정 불필요
3. **성능**: 직접적인 DOM 스타일 조작으로 빠른 렌더링
4. **유지보수성**: 명확한 데이터 → 스타일 매핑

### 🚀 **성능 개선 우선순위**

#### **High Priority**
1. **React.memo** 적용으로 불필요한 리렌더링 방지
2. **useCallback/useMemo** 활용한 핸들러 최적화
3. **Virtual Scrolling** 적용 (엘리먼트 50개 이상 시)

#### **Medium Priority**  
1. **Web Workers**를 활용한 스타일 계산 분리
2. **CSS Custom Properties**로 테마 시스템 구축
3. **IndexedDB** 활용한 로컬 캐싱

#### **Low Priority**
1. CSS-in-JS 마이그레이션 (필요시에만)
2. SCSS 전환 (복잡도 증가 대비 이점 부족)

### 💡 **결론**

현재의 **Tailwind CSS + 인라인 스타일** 하이브리드 방식은 웹 빌더의 요구사항에 매우 적합합니다. 

**핵심 이유:**
- ⚡ **즉시성**: 사용자 입력이 바로 화면에 반영
- 🎯 **정확성**: TypeScript 타입 체크로 안전한 스타일 적용  
- 🔧 **유연성**: 모든 CSS 속성을 동적으로 제어 가능
- 📈 **확장성**: 새로운 엘리먼트 타입 추가가 용이

서버 저장 시에도 JSON 형태의 스타일 데이터는 직관적이고 처리가 간단하여, 복잡한 CSS 생성 로직 없이도 안정적인 웹 빌더를 구축할 수 있습니다.

---

## 📚 학습 포인트

이 프로젝트에서 주목할 만한 현대적 React 개발 패턴:

1. **Feature-Sliced Design**: 확장 가능한 아키텍처
2. **Zustand**: 간단하면서도 강력한 상태 관리
3. **@dnd-kit**: 접근성을 고려한 드래그 앤 드롭
4. **TypeScript**: 타입 안전성을 통한 품질 보장
5. **Tailwind + 인라인 스타일**: 실용적인 하이브리드 접근법

이러한 기술 선택들이 어떻게 웹 빌더라는 복잡한 요구사항을 효율적으로 해결하는지가 이 프로젝트의 핵심 학습 가치입니다.