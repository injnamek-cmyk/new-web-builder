# 웹 빌더 프로젝트 핵심 기능 분석

## 프로젝트 개요

이 Next.js 웹 빌더는 Feature-Sliced Design (FSD) 아키텍처를 기반으로 한 드래그 앤 드롭 비주얼 웹 에디터입니다.

**주요 기술 스택:**
- Frontend: Next.js 15.5.2, React 19.1.0, TypeScript
- 스타일링: Tailwind CSS 4 + 인라인 CSS 스타일
- 상태관리: Zustand
- 드래그 앤 드롭: @dnd-kit
- UI 컴포넌트: shadcn/ui (Radix UI 기반)

---

## 1. Add Element 드롭다운 메뉴 시스템

### 📍 핵심 파일
- `src/widgets/layout.tsx` - 드롭다운 UI 구현
- `src/shared/lib/element-factory.ts` - 엘리먼트 생성 로직
- `src/processes/editor-store.ts` - 상태 관리

### 🔄 작동 원리

```typescript
// 1. 사용자가 드롭다운에서 엘리먼트 타입 선택
const elementTypes = [
  { type: "text", label: "텍스트", icon: <Type /> },
  { type: "button", label: "버튼", icon: <MousePointer2 /> },
  // ... 더 많은 타입들
];

// 2. handleAddElement 함수가 호출됨
const handleAddElement = (type: ElementType) => {
  const newElement = createElement(type);
  addElement(newElement);
};

// 3. createElement가 기본값으로 새 엘리먼트 생성
export function createElement(type: ElementType, overrides: Partial<Element> = {}): Element {
  const baseElement = {
    id: generateId(),
    x: 100, y: 100, // 기본 위치
    width: 200, height: 100, // 기본 크기
    zIndex: 1,
    padding: { top: 8, right: 12, bottom: 8, left: 12 }
  };
  
  // 타입별 특화 속성 추가
  switch (type) {
    case "text":
      return { ...baseElement, content: "새 텍스트", fontSize: 16, ... };
    // ...
  }
}

// 4. Zustand store의 addElement가 상태 업데이트
addElement: (element) => {
  set((state) => ({
    canvas: {
      ...state.canvas,
      elements: [...state.canvas.elements, element],
      selectedElementIds: [element.id]
    }
  }));
  get().saveToHistory();
}
```

### 🎯 데이터 플로우
```
사용자 클릭 → handleAddElement → createElement → addElement (Zustand) → Canvas 리렌더링 → 새 엘리먼트 표시
```

---

## 2. 컴포넌트 캔버스 렌더링 시스템

### 📍 핵심 파일
- `src/widgets/canvas.tsx` - 캔버스 컨테이너
- `src/features/draggable-element.tsx` - 드래그 가능한 래퍼
- `src/entities/*-element.tsx` - 각 엘리먼트 컴포넌트

### 🔄 렌더링 과정

```typescript
// 1. Canvas 컴포넌트가 모든 엘리먼트를 순회
{elements.map((element) => (
  <DraggableElement key={element.id} element={element}>
    {/* 2. 엘리먼트 타입에 따라 적절한 컴포넌트 렌더링 */}
    {renderElement(element)}
  </DraggableElement>
))}

// 3. renderElement 함수가 타입별 컴포넌트 선택
function renderElement(element: Element) {
  switch (element.type) {
    case "text":
      return <TextElementComponent element={element} />;
    case "button":
      return <ButtonElementComponent element={element} />;
    // ...
  }
}
```

### 🎨 위치 및 스타일 적용
각 엘리먼트는 절대 위치(`position: absolute`)로 배치되며, 인라인 스타일로 동적 속성이 적용됩니다:

```typescript
// TextElement 예시
<div
  className="absolute cursor-pointer select-none"
  style={{
    left: element.x,          // 동적 X 위치
    top: element.y,           // 동적 Y 위치
    width: actualWidth,       // 계산된 실제 너비
    height: actualHeight,     // 계산된 실제 높이
    zIndex: element.zIndex,   // Z-인덱스
    fontSize: element.fontSize,
    color: element.color,
    // ... 기타 동적 스타일
  }}
>
```

---

## 3. 속성 패널 커스터마이징 시스템

### 📍 핵심 파일
- `src/widgets/property-panel.tsx` - 속성 패널 메인
- `src/processes/editor-store.ts` - 엘리먼트 업데이트 로직

### 🔄 동적 속성 렌더링

```typescript
// 1. 선택된 엘리먼트 타입에 따라 다른 속성 폼 렌더링
const renderProperties = () => {
  if (!selectedElement) return null;
  
  switch (selectedElement.type) {
    case "text":
      return renderTextProperties(selectedElement);
    case "button":  
      return renderButtonProperties(selectedElement);
    // ...
  }
};

// 2. 타입별 속성 렌더링 함수
const renderTextProperties = (element: TextElement) => (
  <>
    {/* 공통 속성 */}
    <PropertyInput label="X 위치" value={element.x} onChange={...} />
    <PropertyInput label="Y 위치" value={element.y} onChange={...} />
    
    {/* 텍스트 특화 속성 */}
    <PropertyInput label="텍스트" value={element.content} onChange={...} />
    <PropertyInput label="글자 크기" value={element.fontSize} onChange={...} />
    <ColorPicker label="색상" value={element.color} onChange={...} />
  </>
);
```

### 🎛️ 스마트 타입 변환 시스템

```typescript
// 자동 타입 변환 핸들러
const createAutoTypeHandler = (property: string, elementId: string) => {
  return (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    const inputType = e.target.type;
    
    let processedValue: string | number = value;
    
    // 숫자 타입 자동 변환
    if (inputType === "number") {
      processedValue = value === "" ? 0 : parseFloat(value);
    }
    // 텍스트 타입 스마트 처리 (auto 키워드 지원)
    else if (inputType === "text") {
      if (value === "auto") {
        processedValue = "auto";
      } else {
        const numValue = parseFloat(value);
        processedValue = isNaN(numValue) ? value : numValue;
      }
    }
    
    updateElement(elementId, { [property]: processedValue });
  };
};
```

---

## 4. 그리드 스냅 시스템

### 📍 핵심 파일
- `src/processes/editor-store.ts` - 그리드 설정 및 스냅 로직
- `src/widgets/canvas.tsx` - 그리드 시각화

### 🔄 그리드 스냅 알고리즘

```typescript
// 그리드 설정
interface GridConfig {
  showGrid: boolean;      // 그리드 표시 여부
  columns: 24;           // 24컬럼 그리드
  rows: 20;              // 20로우 그리드
  cellSize: 80;          // 80px 셀 크기 (1920px ÷ 24 = 80px)
  snapToGrid: boolean;   // 스냅 활성화 여부
}

// 스냅 계산 함수
snapToGrid: (x: number, y: number) => {
  const { grid } = get();
  if (!grid.snapToGrid) return { x, y };
  
  const cellSize = grid.cellSize;
  return {
    x: Math.round(x / cellSize) * cellSize,  // 가장 가까운 그리드 점으로 스냅
    y: Math.round(y / cellSize) * cellSize,
  };
}
```

### 🎨 그리드 시각화 (SVG 패턴 사용)

```typescript
// 효율적인 SVG 패턴으로 그리드 렌더링
<svg className="absolute inset-0 pointer-events-none">
  <defs>
    <pattern
      id="grid"
      width={grid.cellSize}
      height={grid.cellSize}
      patternUnits="userSpaceOnUse"
    >
      <path
        d={`M ${grid.cellSize} 0 L 0 0 0 ${grid.cellSize}`}
        fill="none"
        stroke="rgba(0,0,0,0.1)"
        strokeWidth="1"
      />
    </pattern>
  </defs>
  <rect width="100%" height="100%" fill="url(#grid)" />
</svg>
```

### 🎯 스마트 그리드 표시
그리드는 드래그 중에만 표시되어 UI 복잡도를 줄입니다:

```typescript
// 드래그 상태에 따른 그리드 자동 표시/숨김
if (!grid.showGrid || !isDragging) return null;
```

---

## 5. 줌 인/아웃 시스템

### 📍 핵심 파일
- `src/widgets/canvas.tsx` - 줌 UI 및 로직
- `src/processes/editor-store.ts` - 줌 상태 관리

### 🔄 줌 구현 방식

```typescript
// 1. CSS Transform을 활용한 GPU 가속 줌
<div 
  className="canvas-content"
  style={{ 
    transform: `scale(${canvasZoom})`,
    transformOrigin: "top left"
  }}
>
  {/* 모든 캔버스 콘텐츠 */}
</div>

// 2. 휠 이벤트를 통한 부드러운 줌
const handleWheel = useCallback((e: WheelEvent) => {
  if (!e.ctrlKey && !e.metaKey) return;  // Ctrl/Cmd 키 필수
  e.preventDefault();
  
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;  // 10% 단위 줌
  const newZoom = Math.max(0.1, Math.min(3, canvasZoom * zoomFactor));
  setCanvasZoom(newZoom);
}, [canvasZoom, setCanvasZoom]);

// 3. 드래그 앤 드롭에서 줌 레벨 고려
const handleDragEnd = (event: DragEndEvent) => {
  const { delta } = event;
  
  // 줌 스케일을 고려한 실제 이동 거리 계산
  const scaledDeltaX = delta.x / canvasZoom;
  const scaledDeltaY = delta.y / canvasZoom;
  
  const newX = element.x + scaledDeltaX;
  const newY = element.y + scaledDeltaY;
  
  // 그리드 스냅 적용
  const snappedPosition = snapToGrid(newX, newY);
  moveElement(element.id, snappedPosition.x, snappedPosition.y);
};
```

---

## 6. 드래그 앤 드롭 시스템

### 📍 핵심 파일
- `src/features/drag-drop.tsx` - DnD 컨텍스트 프로바이더
- `src/features/draggable-element.tsx` - 드래그 가능한 엘리먼트 래퍼

### 🔄 @dnd-kit 기반 구현

```typescript
// 1. 센서 설정 (의도하지 않은 드래그 방지)
const sensors = useSensors(
  useSensor(PointerSensor, {
    activationConstraint: {
      distance: 8,  // 8px 이상 이동해야 드래그 시작
    },
  })
);

// 2. 드래그 시작 시 그리드 표시
const handleDragStart = (event: DragStartEvent) => {
  setIsDragging(true);
  
  // 원래 그리드 설정 백업
  const currentGrid = grid.showGrid;
  setOriginalGridShow(currentGrid);
  
  // 드래그 중 그리드 강제 표시
  if (!currentGrid) {
    setGrid({ showGrid: true });
  }
};

// 3. 드래그 종료 시 위치 업데이트 및 그리드 복원
const handleDragEnd = (event: DragEndEvent) => {
  setIsDragging(false);
  
  // 그리드 설정 복원
  if (originalGridShow !== null) {
    setGrid({ showGrid: originalGridShow });
    setOriginalGridShow(null);
  }
  
  // ... 위치 업데이트 로직
};
```

---

## 7. 상태 관리 시스템 (Zustand)

### 📍 핵심 파일
- `src/processes/editor-store.ts` - 메인 에디터 스토어

### 🏗️ 스토어 구조

```typescript
interface EditorState {
  // 캔버스 상태
  canvas: {
    elements: Element[];           // 모든 엘리먼트
    selectedElementIds: string[];  // 선택된 엘리먼트 ID들
    width: 1920;                  // 캔버스 너비
    height: 1080;                 // 캔버스 높이
  };
  
  // 히스토리 (Undo/Redo용)
  history: Canvas[];              // 상태 히스토리
  historyIndex: number;           // 현재 히스토리 인덱스
  
  // UI 상태
  isDragging: boolean;            // 드래그 상태
  isResizing: boolean;            // 리사이징 상태
  canvasZoom: number;             // 줌 레벨
  
  // 그리드 설정
  grid: GridConfig;
}
```

### 🔄 주요 액션들

```typescript
// 엘리먼트 추가
addElement: (element) => {
  set((state) => ({
    canvas: {
      ...state.canvas,
      elements: [...state.canvas.elements, element],
      selectedElementIds: [element.id]  // 새 엘리먼트 자동 선택
    }
  }));
  get().saveToHistory();  // 히스토리 저장
};

// 엘리먼트 속성 업데이트
updateElement: (id, updates) => {
  set((state) => ({
    canvas: {
      ...state.canvas,
      elements: state.canvas.elements.map(el =>
        el.id === id ? { ...el, ...updates } : el
      )
    }
  }));
  get().saveToHistory();
};

// 다중 선택 지원
toggleElementSelection: (id) => {
  set((state) => {
    const isSelected = state.canvas.selectedElementIds.includes(id);
    const newSelection = isSelected
      ? state.canvas.selectedElementIds.filter(selectedId => selectedId !== id)
      : [...state.canvas.selectedElementIds, id];
    
    return {
      canvas: { ...state.canvas, selectedElementIds: newSelection }
    };
  });
};
```

---

## 8. 스타일링 시스템 분석

### 🎨 현재 스타일링 방식: **하이브리드 접근법**

이 프로젝트는 **Tailwind CSS + 인라인 CSS 스타일**의 하이브리드 방식을 사용합니다:

#### **정적 스타일링**: Tailwind CSS
```typescript
// 레이아웃, 상태 표시 등 고정적인 스타일
<div className={cn(
  "absolute cursor-pointer select-none",
  isSelected ? "ring-2 ring-blue-500 ring-offset-2" : ""
)} />
```

#### **동적 스타일링**: 인라인 CSS
```typescript
// 사용자가 조정 가능한 동적 속성들
style={{
  left: element.x,              // 위치
  top: element.y,
  width: actualWidth,           // 크기
  height: actualHeight,
  fontSize: element.fontSize,   // 텍스트 속성
  color: element.color,
  backgroundColor: element.backgroundColor,
  // ... 모든 커스터마이징 가능한 속성
}}
```

---

## 9. 웹 빌더 특성상 동적 스타일링 최적화 분석

### 🎯 **왜 현재 방식이 적절한가?**

#### ✅ **인라인 스타일의 장점 (웹 빌더 특성상)**
1. **실시간 반영**: 속성 변경이 즉시 DOM에 반영
2. **동적 값 처리**: 사용자 입력값을 직접 CSS로 변환 가능
3. **타입 안전성**: TypeScript로 스타일 값 검증 가능
4. **스코프 격리**: 각 엘리먼트의 스타일이 독립적으로 관리

#### ✅ **Tailwind CSS의 장점 (시스템 스타일)**
1. **일관된 디자인 시스템**: 색상, 간격, 타이포그래피 통일
2. **개발 생산성**: 유틸리티 클래스로 빠른 스타일링
3. **번들 최적화**: 사용하지 않는 클래스 자동 제거
4. **반응형 디자인**: 쉬운 반응형 처리

### 🚀 **성능 최적화 측면**

#### **인라인 스타일 vs CSS-in-JS vs 동적 클래스**

| 방식 | 렌더링 속도 | 메모리 사용 | 개발 복잡도 | 웹 빌더 적합성 |
|------|------------|------------|------------|--------------|
| 인라인 스타일 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| CSS-in-JS | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| 동적 클래스 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |

#### **현재 방식의 성능 장점**
- CSS 파싱/매칭 단계 생략
- 스타일 계산이 직접적
- 리플로우/리페인트 최소화

---

## 10. 서버 저장 스타일링 데이터 처리 방안

### 🏗️ **권장 아키텍처: JSON + CSS 변수 하이브리드**

#### **Phase 1: 현재 구조 유지 (JSON 저장)**
```json
{
  "elements": [
    {
      "id": "text-1",
      "type": "text",
      "x": 100,
      "y": 200,
      "width": 300,
      "height": "auto",
      "content": "Hello World",
      "fontSize": 24,
      "color": "#333333",
      "fontFamily": "Inter",
      "textAlign": "center"
    }
  ]
}
```

#### **Phase 2: CSS 변수 최적화 (향후 고려)**
```json
{
  "cssVariables": {
    "--primary-color": "#3b82f6",
    "--text-lg": "18px",
    "--spacing-md": "16px"
  },
  "elements": [
    {
      "id": "text-1",
      "styles": {
        "color": "var(--primary-color)",
        "fontSize": "var(--text-lg)"
      }
    }
  ]
}
```

### 🎯 **성능 최적화 전략**

#### **1. 청크 단위 로딩**
```typescript
// 큰 프로젝트의 경우 섹션별 로딩
interface ProjectChunk {
  id: string;
  elements: Element[];
  viewport: { x: number, y: number, width: number, height: number };
}

// 현재 뷰포트 영역의 엘리먼트만 로딩
const loadVisibleElements = async (viewport: Viewport) => {
  const chunks = await api.getProjectChunks(projectId, viewport);
  return chunks.flatMap(chunk => chunk.elements);
};
```

#### **2. 증분 업데이트**
```typescript
// 전체 프로젝트 다시 저장하지 않고 변경된 엘리먼트만 업데이트
interface ElementUpdate {
  id: string;
  changes: Partial<Element>;
  timestamp: number;
}

const saveElementChanges = debounce(async (updates: ElementUpdate[]) => {
  await api.updateElements(projectId, updates);
}, 1000);
```

#### **3. 스타일 캐싱**
```typescript
// 자주 사용되는 스타일 조합을 캐시
interface StylePreset {
  id: string;
  name: string;
  styles: Partial<Element>;
}

const applyStylePreset = (elementId: string, presetId: string) => {
  const preset = styleCache.get(presetId);
  if (preset) {
    updateElement(elementId, preset.styles);
  }
};
```

### 🔄 **데이터 동기화 전략**

#### **실시간 협업을 위한 OT (Operational Transformation)**
```typescript
interface Operation {
  type: 'update' | 'create' | 'delete' | 'move';
  elementId: string;
  changes: any;
  userId: string;
  timestamp: number;
}

// 충돌 해결 알고리즘
const resolveConflicts = (localOps: Operation[], remoteOps: Operation[]) => {
  // Last-write-wins 또는 정교한 OT 알고리즘 적용
  return mergeOperations(localOps, remoteOps);
};
```

---

## 11. 최종 권장사항

### 🎯 **현재 스타일링 방식 유지 이유**

1. **웹 빌더 특성상 최적**: 사용자 커스터마이징이 주요 기능
2. **개발 생산성**: 복잡한 CSS-in-JS 설정 불필요
3. **성능**: 직접적인 DOM 스타일 조작으로 빠른 렌더링
4. **유지보수성**: 명확한 데이터 → 스타일 매핑

### 🚀 **성능 개선 우선순위**

#### **High Priority**
1. **React.memo** 적용으로 불필요한 리렌더링 방지
2. **useCallback/useMemo** 활용한 핸들러 최적화
3. **Virtual Scrolling** 적용 (엘리먼트 50개 이상 시)

#### **Medium Priority**  
1. **Web Workers**를 활용한 스타일 계산 분리
2. **CSS Custom Properties**로 테마 시스템 구축
3. **IndexedDB** 활용한 로컬 캐싱

#### **Low Priority**
1. CSS-in-JS 마이그레이션 (필요시에만)
2. SCSS 전환 (복잡도 증가 대비 이점 부족)

### 💡 **결론**

현재의 **Tailwind CSS + 인라인 스타일** 하이브리드 방식은 웹 빌더의 요구사항에 매우 적합합니다. 

**핵심 이유:**
- ⚡ **즉시성**: 사용자 입력이 바로 화면에 반영
- 🎯 **정확성**: TypeScript 타입 체크로 안전한 스타일 적용  
- 🔧 **유연성**: 모든 CSS 속성을 동적으로 제어 가능
- 📈 **확장성**: 새로운 엘리먼트 타입 추가가 용이

서버 저장 시에도 JSON 형태의 스타일 데이터는 직관적이고 처리가 간단하여, 복잡한 CSS 생성 로직 없이도 안정적인 웹 빌더를 구축할 수 있습니다.

---

## 📚 학습 포인트

이 프로젝트에서 주목할 만한 현대적 React 개발 패턴:

1. **Feature-Sliced Design**: 확장 가능한 아키텍처
2. **Zustand**: 간단하면서도 강력한 상태 관리
3. **@dnd-kit**: 접근성을 고려한 드래그 앤 드롭
4. **TypeScript**: 타입 안전성을 통한 품질 보장
5. **Tailwind + 인라인 스타일**: 실용적인 하이브리드 접근법

이러한 기술 선택들이 어떻게 웹 빌더라는 복잡한 요구사항을 효율적으로 해결하는지가 이 프로젝트의 핵심 학습 가치입니다.

---
---

# 추가 분석: 고급 아키텍처

기존 분석 외에, 이 프로젝트는 더욱 정교한 최신 웹 아키텍처 패턴을 사용하고 있습니다.

## 12. 서버 드리븐 UI (SDUI) 렌더링 아키텍처

이 웹 빌더는 에디터와 프리뷰(실제 결과물)를 분리하여 **서버 드리븐 UI (SDUI)** 방식으로 최종 페이지를 렌더링합니다. 이는 에디터의 복잡한 로직과 실제 사용자에게 보여지는 페이지를 완전히 분리하여 성능과 유지보수성을 극대화하는 전략입니다.

### 📍 핵심 파일
- **API 엔드포인트**: `src/app/api/render/[id]/route.ts`
- **프리뷰 페이지**: `src/app/preview/[id]/page.tsx`
- **하이브리드 렌더러**: `src/features/server-driven-ui/hybrid-renderer.tsx`
- **동적 엘리먼트**: `src/features/server-driven-ui/dynamic-element.tsx`

### 🔄 데이터 플로우
```
1. 사용자, /preview/[id] 접속
   │
   └─> 2. PreviewPage 컴포넌트, useEffect에서 /api/render/[id] API 호출
         │
         └─> 3. GET /api/render/[id]
               │
               ├─> 4. 서버, 메모리 스토어에서 페이지 데이터 조회
               │
               └─> 5. 페이지 데이터를 렌더링에 최적화된 JSON (PageRenderData)으로 가공 후 응답
                     - 이 JSON이 바로 '서버가 UI를 정의'하는 핵심 데이터
                     - (예: { pageId, title, canvas: { elements: [...] } })
   │
   └─> 6. PreviewPage, API 응답 JSON을 수신하여 `renderData` state에 저장
         │
         └─> 7. <HybridRenderer> 컴포넌트에 `renderData.canvas.elements` 전달
               │
               ├─> 8. HybridRenderer, 엘리먼트 목록을 순회하며 재귀적으로 렌더링
               │     - 부모-자식 관계(tree)를 재구성
               │     - 각 엘리먼트를 <DynamicElement>로 렌더링
               │
               └─> 9. DynamicElement, 엘리먼트의 `type`에 따라 실제 UI 컴포넌트
                     (예: <TextElementComponent>, <ButtonElementComponent>)를 렌더링하고 스타일 적용
   │
   └─> 10. 최종 UI가 사용자에게 표시됨
```

### 🎯 아키텍처의 장점
- **분리된 관심사**: 에디터의 복잡성(DND, 속성 패널 등)이 최종 결과물에 전혀 영향을 주지 않습니다.
- **성능**: 프리뷰 페이지는 순수하게 데이터(JSON)를 받아 렌더링만 하므로 매우 가볍고 빠릅니다.
- **유연성**: 서버에서 보내주는 JSON 구조만 변경하면 클라이언트 코드 수정 없이도 UI를 변경하거나 새로운 엘리먼트를 추가할 수 있습니다.
- **다중 플랫폼 지원**: 동일한 JSON 데이터를 웹, 모바일 앱 등 다양한 클라이언트에서 재사용하여 일관된 UI를 렌더링할 수 있습니다.

---

## 13. 하이브리드 레이아웃 시스템

단순히 절대 위치(absolute)에만 의존하지 않고, 최신 웹 표준인 **Flexbox, Grid, Flow 레이아웃**을 컨테이너 내에서 사용할 수 있는 정교한 시스템입니다.

### 📍 핵심 파일
- **타입 정의**: `src/shared/types/index.ts` (`ContainerElement`, `LayoutMode` 등)
- **상태 관리**: `src/processes/editor-store.ts` (컨테이너 자식 및 레이아웃 관리 액션)
- **UI**: `src/widgets/property-panel.tsx` (레이아웃 모드 설정 UI)
- **렌더러**: `src/features/server-driven-ui/hybrid-renderer.tsx` (레이아웃 로직 실제 구현)

### 🏗️ 시스템 구조
1.  **`ContainerElement` 확장**:
    -   `layoutMode`: "absolute" | "flex" | "grid" | "flow" 중 하나를 가집니다.
    -   `children`: 컨테이너에 속한 자식 엘리먼트들의 ID 배열. 이를 통해 평면적인 엘리먼트 목록에서 부모-자식 관계의 트리 구조를 형성합니다.
    -   `flex`, `grid`: 각 레이아웃 모드에 대한 상세 속성(예: `flexDirection`, `gridTemplateColumns`)을 담는 객체.

2.  **에디터 (Property Panel)**:
    -   사용자가 컨테이너를 선택하면, 속성 패널에 '레이아웃 모드'를 변경할 수 있는 드롭다운이 나타납니다.
    -   선택된 모드에 따라 Flexbox 설정(방향, 정렬 등)이나 Grid 설정(컬럼, 행 등)을 할 수 있는 전용 UI가 동적으로 렌더링됩니다.

3.  **상태 관리 (Zustand)**:
    -   `addChildToContainer`, `removeChildFromContainer`: 드래그 앤 드롭으로 컨테이너에 다른 엘리먼트를 넣거나 뺄 때 호출됩니다.
    -   `setContainerLayoutMode`, `updateContainerLayout`: 속성 패널에서 사용자가 레이아웃 설정을 변경할 때 호출되어 상태를 업데이트합니다.

4.  **렌더링 (HybridRenderer)**:
    -   렌더링 시, `children` 배열을 이용해 엘리먼트 목록을 트리 구조로 변환합니다.
    -   컨테이너 엘리먼트를 렌더링할 때 `layoutMode`를 확인합니다.
    -   `flex` 모드이면, 컨테이너 div에 `display: flex`와 관련 스타일을 적용하고 자식들을 렌더링합니다.
    -   `grid` 모드이면, `display: grid`와 관련 스타일을 적용합니다.
    -   `absolute` 모드이면, 기존 방식대로 자식들을 절대 위치로 렌더링합니다.

### ✨ 기대 효과
- **고급 레이아웃 구현**: 절대 위치만으로는 만들기 어려운 복잡하고 반응형인 UI 구조를 사용자가 직접 만들 수 있습니다.
- **생산성 향상**: 자동 정렬, 간격 조절 등 레이아웃 시스템의 이점을 활용해 페이지를 더 빠르고 쉽게 디자인할 수 있습니다.
- **현실적인 웹 페이지 제작**: 실제 웹사이트에서 사용하는 거의 모든 레이아웃 기법을 웹 빌더 내에서 구현할 수 있게 됩니다.

---

## 14. (추론) 고급 기능: 서버단 레이아웃 분석 및 최적화

프로젝트 내 `enhanced-render`, `layout-analysis` API의 존재는 단순한 SDUI를 넘어선 고급 기능을 암시합니다.

- **`layout-analysis` API**: 서버에서 페이지의 레이아웃 구조를 분석하여 문제점(예: 요소 겹침, 정렬 불일치)을 진단하거나, 더 나은 구조(예: Flexbox 사용 제안)를 추천하는 역할을 할 수 있습니다. `layout-optimizer.ts`가 이 로직을 담당할 가능성이 높습니다.
- **`enhanced-render` API**: `layout-analysis`의 결과를 바탕으로, 최적화된 레이아웃 JSON을 동적으로 생성하여 클라이언트에 전달할 수 있습니다. 예를 들어, 사용자가 엉성하게 배치한 요소들을 서버가 자동으로 정렬하여 보여주는 '자동 최적화' 렌더링 모드를 구현할 수 있습니다.

이러한 기능들은 AI를 결합하여 사용자 디자인을 자동으로 개선해주는 차세대 웹 빌더로 발전할 수 있는 기반이 됩니다.

---
---

# 추가 분석: 백엔드 및 데이터 관리

기존 분석은 프론트엔드 렌더링과 상태 관리에 중점을 두었습니다. 이 섹션에서는 사용자의 작업을 영구적으로 저장하고 관리하는 백엔드 시스템을 분석합니다.

## 15. 사용자 인증 시스템 (NextAuth.js)

이 프로젝트는 NextAuth.js를 사용하여 강력하고 안전한 인증 시스템을 구축했습니다.

### 📍 핵심 파일
- **인증 로직**: `src/app/api/auth/[...nextauth]/route.ts`
- **라우트 보호**: `src/middleware.ts`
- **DB 모델**: `prisma/schema.prisma` (User, Account, Session 모델)
- **로그인 UI**: `src/app/login/page.tsx`

### 🔄 작동 원리
1.  **Prisma 연동**: `@auth/prisma-adapter`를 사용하여 NextAuth.js의 세션 및 사용자 정보를 데이터베이스에 자동으로 관리합니다.
2.  **자격 증명 기반 인증**: `CredentialsProvider`를 통해 표준 이메일/비밀번호 로그인 방식을 구현했습니다. 사용자가 제공한 비밀번호는 `bcrypt`를 사용해 해싱된 후 데이터베이스에 저장된 값과 비교됩니다.
3.  **세션 관리**: JWT(JSON Web Token) 세션 전략을 사용합니다. 로그인 성공 시, 암호화된 토큰이 클라이언트에게 발급되며, 이 토큰에는 `user.id`가 포함되어 후속 API 요청에서 사용자를 식별하는 데 사용됩니다.
4.  **경로 보호**: `middleware.ts` 파일은 `withAuth` 헬퍼를 사용하여 특정 경로(`'/'`, `'/editor/:path*'`)로의 접근을 제어합니다. 인증되지 않은 사용자가 이 경로에 접근하면 로그인 페이지(`/login`)로 자동 리디렉션됩니다.

### 🎯 데이터 플로우 (로그인)
```
1. 사용자가 /login 페이지에서 이메일과 비밀번호 입력 후 제출
   │
   └─> 2. POST /api/auth/callback/credentials API 호출
         │
         └─> 3. NextAuth의 `authorize` 함수 실행
               │
               ├─> 4. Prisma를 통해 DB에서 사용자 조회
               │
               ├─> 5. `bcrypt.compare`로 비밀번호 일치 여부 검증
               │
               └─> 6. 검증 성공 시, 사용자 정보 반환
   │
   └─> 7. JWT 세션 토큰 생성 및 쿠키에 저장
         │
         └─> 8. 사용자는 원래 요청했던 보호된 페이지(예: /editor)로 리디렉션됨
```

---

## 16. 데이터베이스 스키마 및 페이지 영속성 (Prisma & API)

사용자가 웹 빌더에서 생성한 모든 페이지와 그 내용은 Prisma와 REST API를 통해 SQLite 데이터베이스에 영구적으로 저장됩니다.

### 📍 핵심 파일
- **DB 스키마**: `prisma/schema.prisma`
- **페이지 생성/목록 조회 API**: `src/app/api/pages/route.ts`
- **페이지 개별 CRUD API**: `src/app/api/pages/[id]/route.ts`

### 🏗️ 데이터베이스 스키마 (Prisma)
- **`User` 모델**: 사용자 계정 정보를 저장합니다. (id, name, email, password 등)
- **`Page` 모델**: 생성된 각 웹 페이지에 대한 정보를 저장합니다.
    - `id`: 페이지의 고유 식별자.
    - `userId`: 페이지를 생성한 사용자의 ID (`User` 모델과 관계 형성).
    - `content` (`Json` 타입): **이 시스템의 핵심**. 에디터의 모든 상태(엘리먼트 목록, 위치, 스타일, 내용, 레이아웃 설정 등)가 포함된 **거대한 JSON 객체**가 이 필드 하나에 통째로 저장됩니다. 이는 서버 드리븐 UI(SDUI)와 페이지 렌더링의 원천 데이터가 됩니다.

### 🔄 페이지 CRUD API
프로젝트는 표준 RESTful API 엔드포인트를 통해 페이지 데이터의 생성, 조회, 업데이트, 삭제(CRUD)를 처리합니다. 모든 API는 `getServerSession`을 통해 요청이 인증되었는지, 그리고 해당 페이지에 대한 권한이 있는지 확인합니다.

- **`POST /api/pages`**: (Create) 새 페이지를 생성합니다. 인증된 사용자의 `userId`와 에디터의 초기 상태를 `content` 필드에 담아 DB에 저장합니다.
- **`GET /api/pages`**: (Read) 현재 로그인된 사용자가 소유한 모든 페이지의 목록을 조회합니다.
- **`GET /api/pages/[id]`**: (Read) 특정 ID를 가진 페이지의 `content` 데이터를 조회합니다. 이 API는 주로 `preview` 페이지에서 최종 결과물을 렌더링하기 위해 사용됩니다.
- **`PUT /api/pages/[id]`**: (Update) 에디터에서 페이지를 수정한 후 '저장'할 때 호출됩니다. 요청 본문에 담긴 최신 `content` JSON으로 DB를 업데이트합니다. `upsert`를 사용하여 페이지가 없으면 생성하는 로직도 포함되어 있습니다.
- **`DELETE /api/pages/[id]`**: (Delete) 특정 페이지를 DB에서 삭제합니다.

### 🎯 데이터 플로우 (페이지 저장)
```
1. 사용자가 에디터에서 페이지 내용을 수정하고 '저장' 버튼 클릭
   │
   └─> 2. 클라이언트, 현재 에디터의 전체 상태를 JSON으로 직렬화
         │
         └─> 3. PUT /api/pages/{pageId} API에 JSON 데이터를 담아 요청
               │
               ├─> 4. 서버, 요청 헤더의 세션 토큰으로 사용자 인증 및 ID 획득
               │
               ├─> 5. DB에서 해당 pageId의 소유자가 현재 사용자인지 확인 (보안 검사)
               │
               └─> 6. 검증 통과 시, `prisma.page.update` 실행하여 `content` 필드를 새 JSON으로 덮어씀
   │
   └─> 7. 서버, 성공 응답 반환
```