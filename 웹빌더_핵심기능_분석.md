# 웹 빌더 프로젝트 핵심 기능 분석

## 프로젝트 개요

이 Next.js 웹 빌더는 Feature-Sliced Design (FSD) 아키텍처를 기반으로 한 드래그 앤 드롭 비주얼 웹 에디터입니다.

**주요 기술 스택:**
- Frontend: Next.js 15.5.2, React 19.1.0, TypeScript
- 스타일링: Tailwind CSS 4 + 인라인 CSS 스타일
- 상태관리: Zustand
- 드래그 앤 드롭: @dnd-kit
- UI 컴포넌트: shadcn/ui (Radix UI 기반)

---

## 1. Add Element 드롭다운 메뉴 시스템

### 📍 핵심 파일
- `src/widgets/layout.tsx` - 드롭다운 UI 구현
- `src/shared/lib/element-factory.ts` - 엘리먼트 생성 로직
- `src/processes/editor-store.ts` - 상태 관리

### 🔄 작동 원리 (실제 코드 기준)

`layout.tsx`의 UI, `element-factory.ts`의 생성 로직, `editor-store.ts`의 상태 관리가 함께 동작합니다.

```typescript
// 1. 사용자가 드롭다운 메뉴에서 엘리먼트 타입 선택
// 파일: src/widgets/layout.tsx
const elementTypes: { type: ElementType; label: string; icon: React.ReactNode; }[] = [
  { type: "text", label: "텍스트", icon: <Type className="w-4 h-4" /> },
  { type: "image", label: "이미지", icon: <Image className="w-4 h-4" /> },
  // ... 더 많은 타입들
];

// 2. handleAddElement 함수가 호출됨
// 파일: src/widgets/layout.tsx
const handleAddElement = (type: ElementType) => {
  const element = createElement(type, generateId());
  addElement(element);
};

// 3. createElement가 타입에 맞는 기본값으로 새 엘리먼트 생성
// 파일: src/shared/lib/element-factory.ts
export function createElement(
  type: ElementType,
  id: string,
  x: number = 100,
  y: number = 100,
  options?: Partial<Element>
): Element {
  const baseElement = { id, x, y, zIndex: 0, /* ... */ };

  switch (type) {
    case "text":
      return {
        ...baseElement,
        type: "text",
        width: "auto",
        height: "auto",
        content: "새 텍스트",
        fontSize: 14,
        fontFamily: "Inter",
        color: "hsl(var(--foreground))",
        // ...기타 텍스트 속성들
      } as TextElement;
    // ... 다른 타입들
  }
}

// 4. Zustand store의 addElement가 상태를 업데이트하고 히스토리에 저장
// 파일: src/processes/editor-store.ts
addElement: (element) => {
  set((state) => ({
    canvas: {
      ...state.canvas,
      elements: [...state.canvas.elements, element],
      selectedElementIds: [element.id], // 새 엘리먼트 자동 선택
    },
  }));
  get().saveToHistory(); // Undo/Redo를 위해 히스토리 저장
},
```

### 🎯 데이터 플로우
```
사용자 클릭 → handleAddElement → createElement → addElement (Zustand) → Canvas 리렌더링 → 새 엘리먼트 표시
```

---

## 2. 컴포넌트 캔버스 렌더링 시스템

### 📍 핵심 파일
- `src/widgets/canvas.tsx` - 캔버스 컨테이너
- `src/features/draggable-element.tsx` - 드래그 가능한 래퍼
- `src/entities/*-element.tsx` - 각 엘리먼트 컴포넌트

### 🔄 렌더링 과정 (실제 코드 기준)

실제 렌더링은 `src/features/server-driven-ui/hybrid-renderer.tsx` 파일의 `HybridRenderer` 컴포넌트가 담당하며, 재귀적인 구조로 되어 있습니다.

1.  **`HybridRenderer` (진입점)**: 최상위 엘리먼트들을 찾아 각각 `HybridElement` 컴포넌트로 렌더링합니다.
2.  **`HybridElement` (재귀 렌더링)**: 각 엘리먼트의 `layoutMode` (absolute, flex 등)에 맞는 스타일을 적용하고, 자식 엘리먼트가 있다면 `HybridElement` 자신을 다시 호출하여 트리 구조를 그려나갑니다.
3.  **`renderElementContent` (콘텐츠 렌더링)**: `type`에 따라 `Text`, `Button` 등 실제 내용을 담은 UI 컴포넌트를 `switch` 구문을 통해 렌더링합니다.

아래는 해당 파일의 핵심 로직을 간추린 실제 코드입니다.

```typescript
// 파일: src/features/server-driven-ui/hybrid-renderer.tsx

// 1. 진입점 컴포넌트
export function HybridRenderer({ elements, ... }: HybridRendererProps) {
  // 최상위 요소들을 찾아 렌더링 시작
  const topLevelElements = elements.filter(/* ... */);

  return (
    <div style={/* ... */}>
      {topLevelElements.map((element) => (
        <HybridElement 
          key={element.id} 
          element={element} 
          elementMap={elementMap}
        />
      ))}
    </div>
  );
}

// 2. 재귀적으로 엘리먼트를 렌더링하는 컴포넌트
function HybridElement({ element, elementMap }: HybridElementProps) {
  // 자식 엘리먼트들을 가져옴
  const childElements = element.children.map(/* ... */);
  
  // 레이아웃 모드에 따라 스타일 계산
  const layoutStyle = getLayoutStyle(); // absolute, flex, grid 등 처리

  // 컨테이너일 경우, 자식들을 재귀적으로 렌더링
  if (element.type === "container") {
    return (
      <div style={layoutStyle}>
        {childElements.map(child => (
          <HybridElement /* ... */ />
        ))}
      </div>
    );
  }

  // 다른 엘리먼트들은 콘텐츠 렌더링 함수 호출
  return (
    <div style={layoutStyle}>
      {renderElementContent(element)}
    </div>
  );
}

// 3. 타입에 따라 실제 UI를 렌더링하는 함수 (MD 파일의 renderElement와 가장 유사)
function renderElementContent(element: HybridRenderElement) {
  switch (element.type) {
    case "text":
      return (
        <div style={/* ... */}>
          {element.props.content}
        </div>
      );

    case "image":
      return <Image src={element.props.src} /* ... */ />;

    case "button":
      return (
        <Button style={/* ... */}>
          {element.props.text}
        </Button>
      );
    
    // ... 기타 엘리먼트 타입들
    
    default:
      return <div>Unknown element: {element.type}</div>;
  }
}
```

### 🎨 위치 및 스타일 적용
각 엘리먼트는 절대 위치(`position: absolute`)로 배치되며, 인라인 스타일로 동적 속성이 적용됩니다:

```typescript
// TextElement 예시
<div
  className="absolute cursor-pointer select-none"
  style={{
    left: element.x,          // 동적 X 위치
    top: element.y,           // 동적 Y 위치
    width: actualWidth,       // 계산된 실제 너비
    height: actualHeight,     // 계산된 실제 높이
    zIndex: element.zIndex,   // Z-인덱스
    fontSize: element.fontSize,
    color: element.color,
    // ... 기타 동적 스타일
  }}
>
```

---

## 3. 속성 패널 커스터마이징 시스템

### 📍 핵심 파일
- `src/widgets/property-panel.tsx` - 속성 패널 메인
- `src/processes/editor-store.ts` - 엘리먼트 업데이트 로직

### 🔄 동적 속성 렌더링 (실제 코드 기준)

`property-panel.tsx` 파일은 선택된 엘리먼트의 `type`에 따라 동적으로 다른 속성 편집 UI를 렌더링합니다.

1.  **`PropertyPanel` 컴포넌트**: Zustand 스토어에서 현재 선택된 엘리먼트 정보를 가져옵니다.
2.  **`renderSpecificProperties` 함수**: `switch` 구문을 사용해 엘리먼트 타입에 맞는 렌더링 함수(예: `renderTextProperties`)를 호출합니다.
3.  **타입별 렌더링 함수**: 각 타입에 맞는 UI 컨트롤(Input, Select 등)을 렌더링하고, `onChange` 이벤트가 발생하면 스토어의 `updateElement` 액션을 호출합니다.

```typescript
// 파일: src/widgets/property-panel.tsx

export default function PropertyPanel() {
  const { canvas, updateElement } = useEditorStore();

  // 1. 단일 선택된 엘리먼트 정보 가져오기
  const selectedElement = canvas.elements.find(
    (el) => el.id === canvas.selectedElementIds[0]
  );

  if (!selectedElement) {
    return <p>요소를 선택하세요.</p>;
  }

  // 3. `updateElement`를 호출하는 일반 핸들러
  const handlePropertyChange = (property: string, value: any) => {
    updateElement(selectedElement.id, { [property]: value });
  };

  // 2. 타입에 따라 다른 UI를 렌더링하는 함수
  const renderSpecificProperties = () => {
    switch (selectedElement.type) {
      case "text":
        return renderTextProperties(selectedElement);
      case "button":
        return renderButtonProperties(selectedElement);
      // ... 다른 타입들
      default:
        return null;
    }
  };

  // 3. 텍스트 엘리먼트의 속성 UI를 렌더링하는 함수
  const renderTextProperties = (element: TextElement) => (
    <div className="space-y-4">
      <div>
        <Label htmlFor="content">내용</Label>
        <Textarea
          id="content"
          value={element.content}
          onChange={(e) => handlePropertyChange("content", e.target.value)}
        />
      </div>
      <div className="grid grid-cols-2 gap-2">
        <div>
          <Label htmlFor="fontSize">글자 크기</Label>
          <Input
            id="fontSize"
            type="number"
            value={element.fontSize}
            onChange={(e) => handlePropertyChange("fontSize", parseInt(e.target.value))}
          />
        </div>
        <div>
          <Label htmlFor="color">색상</Label>
          <Input
            id="color"
            type="color"
            value={element.color}
            onChange={(e) => handlePropertyChange("color", e.target.value)}
          />
        </div>
      </div>
    </div>
  );

  return (
    <Card className="p-4">
      <h3 className="font-medium">속성</h3>
      {renderSpecificProperties()}
      {/* ... 공통 속성 UI (위치, 크기 등) */}
    </Card>
  );
}
```

### 🎛️ 스마트 타입 변환 시스템 (실제 코드)

MD 파일의 예시와 거의 동일한 `createAutoTypeHandler` 함수가 실제 코드에서도 사용되어, `Input`의 `type`에 따라 문자열 값을 숫자나 "auto" 키워드로 자동 변환해줍니다.

```typescript
// 파일: src/widgets/property-panel.tsx

// 타입 자동 추론을 위한 핸들러 함수
const createAutoTypeHandler = (property: string, elementId: string) => {
  return (e: React.ChangeEvent<HTMLInputElement>) => {
    const input = e.target;
    const value = input.value;
    const inputType = input.type;

    let processedValue: string | number = value;

    if (inputType === "number") {
      processedValue = value === "" ? 0 : parseFloat(value);
      if (isNaN(processedValue)) processedValue = 0;
    } else if (inputType === "text") {
      if (value === "auto") {
        processedValue = "auto";
      } else {
        const numValue = parseFloat(value);
        processedValue = isNaN(numValue) ? value : numValue;
      }
    }

    updateElement(elementId, { [property]: processedValue });
  };
};
```

---

## 4. 그리드 스냅 시스템

### 📍 핵심 파일
- `src/processes/editor-store.ts` - 그리드 설정 및 스냅 로직
- `src/widgets/canvas.tsx` - 그리드 시각화

### 🔄 그리드 스냅 알고리즘 (실제 코드)

그리드 스냅 로직은 `src/processes/editor-store.ts`의 `snapToGrid` 함수에 구현되어 있으며, MD 문서의 예시와 거의 동일합니다.

```typescript
// 파일: src/processes/editor-store.ts

snapToGrid: (x: number, y: number) => {
  const { grid } = get();
  if (!grid.snapToGrid) return { x, y };

  const cellSize = grid.cellSize;

  // 요소의 왼쪽 위 모서리를 기준으로 그리드에 스냅
  return {
    x: Math.round(x / cellSize) * cellSize,
    y: Math.round(y / cellSize) * cellSize,
  };
},
```

### 🎨 그리드 시각화 (실제 코드)

그리드 시각화는 `src/widgets/canvas.tsx`에서 `GridOverlay` 컴포넌트를 호출하여 이루어집니다. 이 컴포넌트는 드래그 중이고, 그리드 표시 옵션이 켜져 있을 때만 렌더링됩니다.

```typescript
// 1. Canvas 컴포넌트에서 GridOverlay 호출
// 파일: src/widgets/canvas.tsx

<GridOverlay
  grid={grid}
  canvasWidth={canvas.width}
  canvasHeight={canvas.height}
  isDragging={isDragging}
/>

// 2. GridOverlay 컴포넌트의 실제 구현
// 파일: src/components/ui/grid-overlay.tsx

export default function GridOverlay({ grid, isDragging }: GridOverlayProps) {
  // 그리드가 켜져있고 드래그 중일 때만 표시
  if (!grid.showGrid || !isDragging) return null;

  const { cellSize } = grid;

  // 그리드 라인을 그리는 SVG 패턴 생성
  const gridPattern = `
    <defs>
      <pattern id="grid" width="${cellSize}" height="${cellSize}" patternUnits="userSpaceOnUse">
        <path d="M ${cellSize} 0 L 0 0 0 ${cellSize}" fill="none" stroke="#e5e7eb" stroke-width="1"/>
      </pattern>
    </defs>
    <rect width="100%" height="100%" fill="url(#grid)" />
  `;

  return (
    <div className="absolute inset-0 pointer-events-none z-0">
      <svg
        width="100%"
        height="100%"
        dangerouslySetInnerHTML={{ __html: gridPattern }}
      />
    </div>
  );
}
```

---

## 5. 줌 인/아웃 시스템

### 📍 핵심 파일
- `src/widgets/canvas.tsx` - 줌 UI 및 로직
- `src/processes/editor-store.ts` - 줌 상태 관리

### 🔄 줌 구현 방식 (실제 코드 기준)

줌 기능은 `editor-store`의 상태, `canvas.tsx`의 UI 및 이벤트 처리, `draggable-element.tsx`의 드래그 보정 로직의 조합으로 구현됩니다.

```typescript
// 1. Zustand 스토어에서 줌 상태 관리
// 파일: src/processes/editor-store.ts
export const useEditorStore = create<EditorStore>((set) => ({
  canvasZoom: 1,
  setCanvasZoom: (zoom) => {
    set({ canvasZoom: Math.max(0.1, Math.min(3, zoom)) });
  },
  // ...
}));

// 2. 캔버스에서 CSS Transform과 휠 이벤트로 줌 UI 구현
// 파일: src/widgets/canvas.tsx
export default function Canvas() {
  const { canvasZoom, setCanvasZoom } = useEditorStore();
  const canvasRef = useRef<HTMLDivElement>(null);

  // Ctrl/Cmd + 휠 이벤트로 줌 조절
  const handleWheel = useCallback((e: WheelEvent) => {
    if (!e.ctrlKey && !e.metaKey) return;
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const newZoom = Math.max(0.1, Math.min(3, canvasZoom * zoomFactor));
    setCanvasZoom(newZoom);
  }, [canvasZoom, setCanvasZoom]);

  // ... useEffect에서 wheel 이벤트 리스너 등록 ...

  return (
    <div ref={canvasRef} /* ... */>
      <div style={{
          width: canvas.width,
          height: canvas.height,
          transform: `scale(${canvasZoom})`, // 줌 레벨 적용
          transformOrigin: "top left",
        }}>
        {/* ... 엘리먼트 렌더링 ... */}
      </div>
    </div>
  );
}

// 3. 드래그 시 줌 레벨을 고려하여 이동 거리 보정
// 파일: src/features/draggable-element.tsx
export default function DraggableElement({ element, children }: DraggableElementProps) {
  const { canvasZoom } = useEditorStore();

  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: element.id,
  });

  // dnd-kit의 transform 값을 줌 레벨로 나누어 실제 이동 거리를 계산
  const style = transform
    ? {
        transform: `translate3d(${transform.x / canvasZoom}px, ${
          transform.y / canvasZoom
        }px, 0)`,
      }
    : undefined;

  return (
    <div ref={setNodeRef} style={style} {...listeners} {...attributes}>
      {children}
    </div>
  );
}
```

---

## 6. 드래그 앤 드롭 시스템

### 📍 핵심 파일
- `src/features/drag-drop.tsx` - DnD 컨텍스트 프로바이더
- `src/features/draggable-element.tsx` - 드래그 가능한 엘리먼트 래퍼

### 🔄 @dnd-kit 기반 구현 (실제 코드)

`@dnd-kit`의 `DndContext`를 설정하고, 드래그 시작/종료 이벤트에 대한 핸들러를 정의하여 전체 드래그 앤 드롭 로직을 관리합니다.

```typescript
// 파일: src/features/drag-drop.tsx

export default function DragDropProvider({ children }: DragDropProviderProps) {
  const { moveElement, setDragging, snapToGrid, canvasZoom, grid, ... } = useEditorStore();

  // 1. 센서 설정 (8px 이상 이동해야 드래그 시작)
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    })
  );

  // 2. 드래그 시작 시 그리드 표시 및 상태 설정
  const handleDragStart = () => {
    setDragging(true);
    // ... (그리드 상태 저장 및 표시 로직) ...
  };

  // 3. 드래그 종료 시 위치 업데이트 및 상태 복원
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, delta } = event;

    if (delta.x !== 0 || delta.y !== 0) {
      const element = canvas.elements.find((el) => el.id === active.id);
      if (element) {
        // 줌 레벨에 맞게 이동 거리 보정
        const scaledDeltaX = delta.x / canvasZoom;
        const scaledDeltaY = delta.y / canvasZoom;

        const newX = element.x + scaledDeltaX;
        const newY = element.y + scaledDeltaY;

        // 그리드에 스냅 적용
        const snappedPosition = snapToGrid(newX, newY);
        
        // Zustand 스토어의 엘리먼트 위치 업데이트
        moveElement(element.id, snappedPosition.x, snappedPosition.y);
      }
    }

    setDragging(false);
    // ... (원래 그리드 상태로 복원) ...
  };

  return (
    <DndContext
      sensors={sensors}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      {children}
    </DndContext>
  );
}
```

---

## 7. 상태 관리 시스템 (Zustand)

### 📍 핵심 파일
- `src/processes/editor-store.ts` - 메인 에디터 스토어

### 🏗️ 스토어 구조 (실제 코드)

`EditorState` 인터페이스는 스토어가 관리하는 모든 상태의 타입을 정의합니다. 실제 스토어는 더 많은 UI 상태와 페이지 관리 상태를 포함합니다.

```typescript
// 파일: src/shared/types/index.ts & src/processes/editor-store.ts

interface EditorState {
  // 페이지 및 저장 상태
  currentPageId: string | null;
  currentPageTitle: string;
  isSaving: boolean;

  // 캔버스 상태
  canvas: Canvas;
  
  // 히스토리 (Undo/Redo용)
  history: Canvas[];
  historyIndex: number;
  
  // UI 상태
  leftPanelVisible: boolean;
  rightPanelVisible: boolean;
  isDragging: boolean;
  isResizing: boolean;
  canvasZoom: number;
  
  // 그리드 설정
  grid: GridConfig;
}

interface Canvas {
  elements: Element[];
  selectedElementIds: string[];
  width: number;
  height: number;
}
```

### 🔄 주요 액션들 (실제 코드)

실제 액션 함수들은 `set`과 `get`을 사용하여 상태를 업데이트하고, 필요에 따라 히스토리 저장을 호출합니다.

```typescript
// 파일: src/processes/editor-store.ts

export const useEditorStore = create<EditorStore>((set, get) => ({
  // ... 초기 상태 ...

  // 엘리먼트 추가
  addElement: (element) => {
    set((state) => ({
      canvas: {
        ...state.canvas,
        elements: [...state.canvas.elements, element],
        selectedElementIds: [element.id], // 새 엘리먼트 자동 선택
      },
    }));
    get().saveToHistory(); // 히스토리 저장
  },

  // 엘리먼트 속성 업데이트
  updateElement: (id, updates) => {
    set((state) => ({
      canvas: {
        ...state.canvas,
        elements: state.canvas.elements.map((element) =>
          element.id === id ? ({ ...element, ...updates } as Element) : element
        ),
      },
    }));
    // 주: 속성 변경은 히스토리에 저장하지 않아 즉각적인 반응성을 보장
  },

  // 다중 선택 토글
  toggleSelection: (id) => {
    set((state) => {
      const isSelected = state.canvas.selectedElementIds.includes(id);
      const newSelection = isSelected
        ? state.canvas.selectedElementIds.filter((selectedId) => selectedId !== id)
        : [...state.canvas.selectedElementIds, id];
      
      return {
        canvas: { ...state.canvas, selectedElementIds: newSelection },
      };
    });
  },

  // 선택된 요소들 삭제
  deleteSelectedElements: () => {
    set((state) => ({
      canvas: {
        ...state.canvas,
        elements: state.canvas.elements.filter(
          (element) => !state.canvas.selectedElementIds.includes(element.id)
        ),
        selectedElementIds: [],
      },
    }));
    get().saveToHistory();
  },
}));
```

---

## 8. 스타일링 시스템 분석

### 🎨 현재 스타일링 방식: **하이브리드 접근법**

이 프로젝트는 **Tailwind CSS + 인라인 CSS 스타일**의 하이브리드 방식을 사용합니다:

#### **정적 스타일링**: Tailwind CSS
```typescript
// 레이아웃, 상태 표시 등 고정적인 스타일
<div className={cn(
  "absolute cursor-pointer select-none",
  isSelected ? "ring-2 ring-blue-500 ring-offset-2" : ""
)} />
```

#### **동적 스타일링**: 인라인 CSS
```typescript
// 사용자가 조정 가능한 동적 속성들
style={{
  left: element.x,              // 위치
  top: element.y,
  width: actualWidth,           // 크기
  height: actualHeight,
  fontSize: element.fontSize,   // 텍스트 속성
  color: element.color,
  backgroundColor: element.backgroundColor,
  // ... 모든 커스터마이징 가능한 속성
}}
```

---

## 9. 웹 빌더 특성상 동적 스타일링 최적화 분석

### 🎯 **왜 현재 방식이 적절한가?**

#### ✅ **인라인 스타일의 장점 (웹 빌더 특성상)**
1. **실시간 반영**: 속성 변경이 즉시 DOM에 반영
2. **동적 값 처리**: 사용자 입력값을 직접 CSS로 변환 가능
3. **타입 안전성**: TypeScript로 스타일 값 검증 가능
4. **스코프 격리**: 각 엘리먼트의 스타일이 독립적으로 관리

#### ✅ **Tailwind CSS의 장점 (시스템 스타일)**
1. **일관된 디자인 시스템**: 색상, 간격, 타이포그래피 통일
2. **개발 생산성**: 유틸리티 클래스로 빠른 스타일링
3. **번들 최적화**: 사용하지 않는 클래스 자동 제거
4. **반응형 디자인**: 쉬운 반응형 처리

### 🚀 **성능 최적화 측면**

#### **인라인 스타일 vs CSS-in-JS vs 동적 클래스**

| 방식 | 렌더링 속도 | 메모리 사용 | 개발 복잡도 | 웹 빌더 적합성 |
|------|------------|------------|------------|--------------|
| 인라인 스타일 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| CSS-in-JS | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| 동적 클래스 | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |

#### **현재 방식의 성능 장점**
- CSS 파싱/매칭 단계 생략
- 스타일 계산이 직접적
- 리플로우/리페인트 최소화

---

## 10. 서버 저장 스타일링 데이터 처리 방안

### 🏗️ **권장 아키텍처: JSON + CSS 변수 하이브리드**

#### **Phase 1: 현재 구조 유지 (JSON 저장)**
```json
{
  "elements": [
    {
      "id": "text-1",
      "type": "text",
      "x": 100,
      "y": 200,
      "width": 300,
      "height": "auto",
      "content": "Hello World",
      "fontSize": 24,
      "color": "#333333",
      "fontFamily": "Inter",
      "textAlign": "center"
    }
  ]
}
```

#### **Phase 2: CSS 변수 최적화 (향후 고려)**
```json
{
  "cssVariables": {
    "--primary-color": "#3b82f6",
    "--text-lg": "18px",
    "--spacing-md": "16px"
  },
  "elements": [
    {
      "id": "text-1",
      "styles": {
        "color": "var(--primary-color)",
        "fontSize": "var(--text-lg)"
      }
    }
  ]
}
```

### 🎯 **성능 최적화 전략**

#### **1. 청크 단위 로딩**
```typescript
// 큰 프로젝트의 경우 섹션별 로딩
interface ProjectChunk {
  id: string;
  elements: Element[];
  viewport: { x: number, y: number, width: number, height: number };
}

// 현재 뷰포트 영역의 엘리먼트만 로딩
const loadVisibleElements = async (viewport: Viewport) => {
  const chunks = await api.getProjectChunks(projectId, viewport);
  return chunks.flatMap(chunk => chunk.elements);
};
```

#### **2. 증분 업데이트**
```typescript
// 전체 프로젝트 다시 저장하지 않고 변경된 엘리먼트만 업데이트
interface ElementUpdate {
  id: string;
  changes: Partial<Element>;
  timestamp: number;
}

const saveElementChanges = debounce(async (updates: ElementUpdate[]) => {
  await api.updateElements(projectId, updates);
}, 1000);
```

#### **3. 스타일 캐싱**
```typescript
// 자주 사용되는 스타일 조합을 캐시
interface StylePreset {
  id: string;
  name: string;
  styles: Partial<Element>;
}

const applyStylePreset = (elementId: string, presetId: string) => {
  const preset = styleCache.get(presetId);
  if (preset) {
    updateElement(elementId, preset.styles);
  }
};
```

### 🔄 **데이터 동기화 전략**

#### **실시간 협업을 위한 OT (Operational Transformation)**
```typescript
interface Operation {
  type: 'update' | 'create' | 'delete' | 'move';
  elementId: string;
  changes: any;
  userId: string;
  timestamp: number;
}

// 충돌 해결 알고리즘
const resolveConflicts = (localOps: Operation[], remoteOps: Operation[]) => {
  // Last-write-wins 또는 정교한 OT 알고리즘 적용
  return mergeOperations(localOps, remoteOps);
};
```

---

## 11. 최종 권장사항

### 🎯 **현재 스타일링 방식 유지 이유**

1. **웹 빌더 특성상 최적**: 사용자 커스터마이징이 주요 기능
2. **개발 생산성**: 복잡한 CSS-in-JS 설정 불필요
3. **성능**: 직접적인 DOM 스타일 조작으로 빠른 렌더링
4. **유지보수성**: 명확한 데이터 → 스타일 매핑

### 🚀 **성능 개선 우선순위**

#### **High Priority**
1. **React.memo** 적용으로 불필요한 리렌더링 방지
2. **useCallback/useMemo** 활용한 핸들러 최적화
3. **Virtual Scrolling** 적용 (엘리먼트 50개 이상 시)

#### **Medium Priority**  
1. **Web Workers**를 활용한 스타일 계산 분리
2. **CSS Custom Properties**로 테마 시스템 구축
3. **IndexedDB** 활용한 로컬 캐싱

#### **Low Priority**
1. CSS-in-JS 마이그레이션 (필요시에만)
2. SCSS 전환 (복잡도 증가 대비 이점 부족)

### 💡 **결론**

현재의 **Tailwind CSS + 인라인 스타일** 하이브리드 방식은 웹 빌더의 요구사항에 매우 적합합니다. 

**핵심 이유:**
- ⚡ **즉시성**: 사용자 입력이 바로 화면에 반영
- 🎯 **정확성**: TypeScript 타입 체크로 안전한 스타일 적용  
- 🔧 **유연성**: 모든 CSS 속성을 동적으로 제어 가능
- 📈 **확장성**: 새로운 엘리먼트 타입 추가가 용이

서버 저장 시에도 JSON 형태의 스타일 데이터는 직관적이고 처리가 간단하여, 복잡한 CSS 생성 로직 없이도 안정적인 웹 빌더를 구축할 수 있습니다.

---

## 📚 학습 포인트

이 프로젝트에서 주목할 만한 현대적 React 개발 패턴:

1. **Feature-Sliced Design**: 확장 가능한 아키텍처
2. **Zustand**: 간단하면서도 강력한 상태 관리
3. **@dnd-kit**: 접근성을 고려한 드래그 앤 드롭
4. **TypeScript**: 타입 안전성을 통한 품질 보장
5. **Tailwind + 인라인 스타일**: 실용적인 하이브리드 접근법

이러한 기술 선택들이 어떻게 웹 빌더라는 복잡한 요구사항을 효율적으로 해결하는지가 이 프로젝트의 핵심 학습 가치입니다.

---
---

# 추가 분석: 고급 아키텍처

기존 분석 외에, 이 프로젝트는 더욱 정교한 최신 웹 아키텍처 패턴을 사용하고 있습니다.

## 12. 서버 드리븐 UI (SDUI) 렌더링 아키텍처

이 웹 빌더는 에디터와 프리뷰(실제 결과물)를 분리하여 **서버 드리븐 UI (SDUI)** 방식으로 최종 페이지를 렌더링합니다. 이는 에디터의 복잡한 로직과 실제 사용자에게 보여지는 페이지를 완전히 분리하여 성능과 유지보수성을 극대화하는 전략입니다.

### 📍 핵심 파일
- **API 엔드포인트**: `src/app/api/render/[id]/route.ts`
- **프리뷰 페이지**: `src/app/preview/[id]/page.tsx`
- **하이브리드 렌더러**: `src/features/server-driven-ui/hybrid-renderer.tsx`
- **동적 엘리먼트**: `src/features/server-driven-ui/dynamic-element.tsx`

### 🔄 데이터 플로우 (실제 코드 기준)

```typescript
// 1. 사용자가 /preview/[id]에 접속하면, 클라이언트 컴포넌트가 API에 데이터 요청
// 파일: src/app/preview/[id]/page.tsx

useEffect(() => {
  if (!pageId) return;

  const fetchRenderData = async () => {
    try {
      setLoading(true);
      // 2. 서버의 /api/render/[id] 엔드포인트 호출
      const response = await fetch(`/api/render/${pageId}`);
      if (!response.ok) {
        throw new Error("Failed to fetch page data");
      }
      const result = await response.json();
      setRenderData(result); // 5. 받은 JSON을 state에 저장
    } catch (err) {
      setError(/* ... */);
    } finally {
      setLoading(false);
    }
  };

  fetchRenderData();
}, [pageId]);


// 3. API 엔드포인트는 DB에서 페이지 데이터를 조회하여 JSON으로 응답
// 파일: src/app/api/render/[id]/route.ts

export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = params;
    // 4. Prisma를 이용해 DB에서 페이지 조회
    const page = await prisma.page.findUnique({
      where: { id },
    });

    if (!page || !page.content) { /* ... error handling ... */ }

    // content 필드(JSON)를 포함한 렌더링 데이터 구성
    const renderData = {
      pageId: page.id,
      ...(page.content as object), // title, canvas 포함
      metadata: { /* ... */ }
    };

    return NextResponse.json(renderData, { status: 200 });
  } catch (error) { /* ... */ }
}


// 6. 클라이언트는 state에 저장된 데이터로 HybridRenderer를 렌더링
// 파일: src/app/preview/[id]/page.tsx

if (renderData) {
  return (
    <main>
      <HybridRenderer
        elements={renderData.canvas.elements}
        canvasWidth={renderData.canvas.width}
        canvasHeight={renderData.canvas.height}
      />
    </main>
  );
}
```

### 🎯 아키텍처의 장점
- **분리된 관심사**: 에디터의 복잡성(DND, 속성 패널 등)이 최종 결과물에 전혀 영향을 주지 않습니다.
- **성능**: 프리뷰 페이지는 순수하게 데이터(JSON)를 받아 렌더링만 하므로 매우 가볍고 빠릅니다.
- **유연성**: 서버에서 보내주는 JSON 구조만 변경하면 클라이언트 코드 수정 없이도 UI를 변경하거나 새로운 엘리먼트를 추가할 수 있습니다.
- **다중 플랫폼 지원**: 동일한 JSON 데이터를 웹, 모바일 앱 등 다양한 클라이언트에서 재사용하여 일관된 UI를 렌더링할 수 있습니다.

---

## 13. 하이브리드 레이아웃 시스템

단순히 절대 위치(absolute)에만 의존하지 않고, 최신 웹 표준인 **Flexbox, Grid, Flow 레이아웃**을 컨테이너 내에서 사용할 수 있는 정교한 시스템입니다.

### 📍 핵심 파일
- **타입 정의**: `src/shared/types/index.ts` (`ContainerElement`, `LayoutMode` 등)
- **상태 관리**: `src/processes/editor-store.ts` (컨테이너 자식 및 레이아웃 관리 액션)
- **UI**: `src/widgets/property-panel.tsx` (레이아웃 모드 설정 UI)
- **렌더러**: `src/features/server-driven-ui/hybrid-renderer.tsx` (레이아웃 로직 실제 구현)

### 🏗️ 시스템 구조
1.  **`ContainerElement` 확장**:
    -   `layoutMode`: "absolute" | "flex" | "grid" | "flow" 중 하나를 가집니다.
    -   `children`: 컨테이너에 속한 자식 엘리먼트들의 ID 배열. 이를 통해 평면적인 엘리먼트 목록에서 부모-자식 관계의 트리 구조를 형성합니다.
    -   `flex`, `grid`: 각 레이아웃 모드에 대한 상세 속성(예: `flexDirection`, `gridTemplateColumns`)을 담는 객체.

2.  **에디터 (Property Panel)**:
    -   사용자가 컨테이너를 선택하면, 속성 패널에 '레이아웃 모드'를 변경할 수 있는 드롭다운이 나타납니다.
    -   선택된 모드에 따라 Flexbox 설정(방향, 정렬 등)이나 Grid 설정(컬럼, 행 등)을 할 수 있는 전용 UI가 동적으로 렌더링됩니다.

3.  **상태 관리 (Zustand)**:
    -   `addChildToContainer`, `removeChildFromContainer`: 드래그 앤 드롭으로 컨테이너에 다른 엘리먼트를 넣거나 뺄 때 호출됩니다.
    -   `setContainerLayoutMode`, `updateContainerLayout`: 속성 패널에서 사용자가 레이아웃 설정을 변경할 때 호출되어 상태를 업데이트합니다.

4.  **렌더링 (HybridRenderer)**:
    -   렌더링 시, `children` 배열을 이용해 엘리먼트 목록을 트리 구조로 변환합니다.
    -   컨테이너 엘리먼트를 렌더링할 때 `layoutMode`를 확인합니다.
    -   `flex` 모드이면, 컨테이너 div에 `display: flex`와 관련 스타일을 적용하고 자식들을 렌더링합니다.
    -   `grid` 모드이면, `display: grid`와 관련 스타일을 적용합니다.
    -   `absolute` 모드이면, 기존 방식대로 자식들을 절대 위치로 렌더링합니다.

### ✨ 기대 효과
- **고급 레이아웃 구현**: 절대 위치만으로는 만들기 어려운 복잡하고 반응형인 UI 구조를 사용자가 직접 만들 수 있습니다.
- **생산성 향상**: 자동 정렬, 간격 조절 등 레이아웃 시스템의 이점을 활용해 페이지를 더 빠르고 쉽게 디자인할 수 있습니다.
- **현실적인 웹 페이지 제작**: 실제 웹사이트에서 사용하는 거의 모든 레이아웃 기법을 웹 빌더 내에서 구현할 수 있게 됩니다.

---

## 14. (추론) 고급 기능: 서버단 레이아웃 분석 및 최적화

프로젝트 내 `enhanced-render`, `layout-analysis` API의 존재는 단순한 SDUI를 넘어선 고급 기능을 암시합니다.

- **`layout-analysis` API**: 서버에서 페이지의 레이아웃 구조를 분석하여 문제점(예: 요소 겹침, 정렬 불일치)을 진단하거나, 더 나은 구조(예: Flexbox 사용 제안)를 추천하는 역할을 할 수 있습니다. `layout-optimizer.ts`가 이 로직을 담당할 가능성이 높습니다.
- **`enhanced-render` API**: `layout-analysis`의 결과를 바탕으로, 최적화된 레이아웃 JSON을 동적으로 생성하여 클라이언트에 전달할 수 있습니다. 예를 들어, 사용자가 엉성하게 배치한 요소들을 서버가 자동으로 정렬하여 보여주는 '자동 최적화' 렌더링 모드를 구현할 수 있습니다.

이러한 기능들은 AI를 결합하여 사용자 디자인을 자동으로 개선해주는 차세대 웹 빌더로 발전할 수 있는 기반이 됩니다.

---
---

# 추가 분석: 백엔드 및 데이터 관리

기존 분석은 프론트엔드 렌더링과 상태 관리에 중점을 두었습니다. 이 섹션에서는 사용자의 작업을 영구적으로 저장하고 관리하는 백엔드 시스템을 분석합니다.

## 15. 사용자 인증 시스템 (NextAuth.js)

이 프로젝트는 NextAuth.js를 사용하여 강력하고 안전한 인증 시스템을 구축했습니다.

### 📍 핵심 파일
- **인증 로직**: `src/app/api/auth/[...nextauth]/route.ts`
- **라우트 보호**: `src/middleware.ts`
- **DB 모델**: `prisma/schema.prisma` (User, Account, Session 모델)
- **로그인 UI**: `src/app/login/page.tsx`

### 🔄 작동 원리
1.  **Prisma 연동**: `@auth/prisma-adapter`를 사용하여 NextAuth.js의 세션 및 사용자 정보를 데이터베이스에 자동으로 관리합니다.
2.  **자격 증명 기반 인증**: `CredentialsProvider`를 통해 표준 이메일/비밀번호 로그인 방식을 구현했습니다. 사용자가 제공한 비밀번호는 `bcrypt`를 사용해 해싱된 후 데이터베이스에 저장된 값과 비교됩니다.
3.  **세션 관리**: JWT(JSON Web Token) 세션 전략을 사용합니다. 로그인 성공 시, 암호화된 토큰이 클라이언트에게 발급되며, 이 토큰에는 `user.id`가 포함되어 후속 API 요청에서 사용자를 식별하는 데 사용됩니다.
4.  **경로 보호**: `middleware.ts` 파일은 `withAuth` 헬퍼를 사용하여 특정 경로(`'/'`, `'/editor/:path*'`)로의 접근을 제어합니다. 인증되지 않은 사용자가 이 경로에 접근하면 로그인 페이지(`/login`)로 자동 리디렉션됩니다.

### 🔄 작동 원리 (실제 코드 기준)

인증은 `middleware.ts`에서의 경로 보호와 `[...nextauth]/route.ts`에서의 자격 증명 확인을 통해 이루어집니다.

```typescript
// 1. 미들웨어가 특정 경로에 대한 접근을 제어
// 파일: src/middleware.ts

import { withAuth } from "next-auth/middleware"

// withAuth 헬퍼를 사용, 인증되지 않은 사용자는 로그인 페이지로 리디렉션
export default withAuth({
  pages: {
    signIn: "/login",
  },
})

// 미들웨어를 적용할 경로 목록
export const config = { 
  matcher: [
    "/",
    "/editor/:path*",
  ],
}


// 2. 사용자가 /login 페이지에서 폼을 제출하면 NextAuth 엔드포인트가 처리
// 3. CredentialsProvider의 authorize 함수가 실행되어 자격 증명을 검증
// 파일: src/app/api/auth/[...nextauth]/route.ts

export const authOptions: AuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: { /* ... */ },
      async authorize(credentials) {
        if (!credentials?.email || !credentials.password) {
          return null;
        }

        // 4. Prisma를 통해 DB에서 사용자 조회
        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user || !user.password) {
          return null;
        }

        // 5. bcrypt.compare로 비밀번호 일치 여부 검증
        const isPasswordValid = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordValid) {
          return null;
        }
        
        // 6. 검증 성공 시, 사용자 정보 반환
        return user;
      },
    }),
  ],
  // ... session, pages 설정 ...
};

// 7. 검증 성공 후 JWT 세션 토큰이 생성되어 클라이언트 쿠키에 저장됨
```

---

## 16. 데이터베이스 스키마 및 페이지 영속성 (Prisma & API)

사용자가 웹 빌더에서 생성한 모든 페이지와 그 내용은 Prisma와 REST API를 통해 SQLite 데이터베이스에 영구적으로 저장됩니다.

### 📍 핵심 파일
- **DB 스키마**: `prisma/schema.prisma`
- **페이지 생성/목록 조회 API**: `src/app/api/pages/route.ts`
- **페이지 개별 CRUD API**: `src/app/api/pages/[id]/route.ts`

### 🏗️ 데이터베이스 스키마 (Prisma)
- **`User` 모델**: 사용자 계정 정보를 저장합니다. (id, name, email, password 등)
- **`Page` 모델**: 생성된 각 웹 페이지에 대한 정보를 저장합니다.
    - `id`: 페이지의 고유 식별자.
    - `userId`: 페이지를 생성한 사용자의 ID (`User` 모델과 관계 형성).
    - `content` (`Json` 타입): **이 시스템의 핵심**. 에디터의 모든 상태(엘리먼트 목록, 위치, 스타일, 내용, 레이아웃 설정 등)가 포함된 **거대한 JSON 객체**가 이 필드 하나에 통째로 저장됩니다. 이는 서버 드리븐 UI(SDUI)와 페이지 렌더링의 원천 데이터가 됩니다.

### 🔄 페이지 CRUD API
프로젝트는 표준 RESTful API 엔드포인트를 통해 페이지 데이터의 생성, 조회, 업데이트, 삭제(CRUD)를 처리합니다. 모든 API는 `getServerSession`을 통해 요청이 인증되었는지, 그리고 해당 페이지에 대한 권한이 있는지 확인합니다.

- **`POST /api/pages`**: (Create) 새 페이지를 생성합니다. 인증된 사용자의 `userId`와 에디터의 초기 상태를 `content` 필드에 담아 DB에 저장합니다.
- **`GET /api/pages`**: (Read) 현재 로그인된 사용자가 소유한 모든 페이지의 목록을 조회합니다.
- **`GET /api/pages/[id]`**: (Read) 특정 ID를 가진 페이지의 `content` 데이터를 조회합니다. 이 API는 주로 `preview` 페이지에서 최종 결과물을 렌더링하기 위해 사용됩니다.
- **`PUT /api/pages/[id]`**: (Update) 에디터에서 페이지를 수정한 후 '저장'할 때 호출됩니다. 요청 본문에 담긴 최신 `content` JSON으로 DB를 업데이트합니다. `upsert`를 사용하여 페이지가 없으면 생성하는 로직도 포함되어 있습니다.
- **`DELETE /api/pages/[id]`**: (Delete) 특정 페이지를 DB에서 삭제합니다.

### 🎯 데이터 플로우 (페이지 저장)
```
1. 사용자가 에디터에서 페이지 내용을 수정하고 '저장' 버튼 클릭
   │
   └─> 2. 클라이언트, 현재 에디터의 전체 상태를 JSON으로 직렬화
         │
         └─> 3. PUT /api/pages/{pageId} API에 JSON 데이터를 담아 요청
               │
               ├─> 4. 서버, 요청 헤더의 세션 토큰으로 사용자 인증 및 ID 획득
               │
               ├─> 5. DB에서 해당 pageId의 소유자가 현재 사용자인지 확인 (보안 검사)
               │
               └─> 6. 검증 통과 시, `prisma.page.update` 실행하여 `content` 필드를 새 JSON으로 덮어씀
   │
   └─> 7. 서버, 성공 응답 반환
```